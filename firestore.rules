rules_version = '2';

/**
 * @file firestore.rules
 * @description Security rules for the Jannu Live application.
 *
 * ## Core Philosophy
 * This ruleset enforces a security model that balances public content discovery with strict user data privacy.
 * Publicly accessible data like user profiles and posts are readable by anyone, but writable only by the content owner.
 * Private data, such as notifications and relationships (follow/like), is strictly controlled.
 *
 * ## Data Structure
 * The structure uses a combination of top-level collections for global, discoverable content (e.g., /posts)
 * and user-nested subcollections for user-centric data (e.g., /users/{userId}/followers). This structural
 * segregation provides a clear and secure separation of concerns.
 *
 * ## Key Security Decisions
 * - User Listing Disabled: To protect privacy, it is not possible for a client to query the entire list of users in the `/users` collection.
 * - Public Reads, Owner Writes: Core content like posts and user profiles are publicly readable to facilitate a social experience,
 *   but all write operations (create, update, delete) are strictly limited to the document's owner or related entities.
 * - Relationship Integrity: Follow, Like, and Save actions are controlled. A user can only initiate actions for themselves (e.g., you can't make someone else follow another person).
 * - Strict Privacy for Communications: Notifications are strictly private to the user they belong to.
 *
 * ## Denormalization for Authorization
 * To create simpler and more performant rules, data required for authorization is denormalized directly onto the documents being secured.
 * For example, `Post` and `Comment` documents contain an `authorId` field. This avoids slow, costly, and sometimes impossible cross-document
 * `get()` calls in security rules, ensuring that authorization decisions are fast and efficient.
 *
 * ## Structural Segregation
 * Data with different security needs are stored in separate collections or subcollections. For example, private user notifications
 * are stored in a user-specific subcollection (`/users/{userId}/notifications`), completely separate from public content like `/posts`.
 */
service cloud.firestore {
  match /databases/{database}/documents {

    // ----------------------------------------
    // Helper Functions
    // ----------------------------------------

    /**
     * @description Checks if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the authenticated user's UID matches the provided userId.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * @description Verifies that the document being accessed already exists.
     * CRITICAL for all update and delete operations.
     */
    function isExistingDoc() {
      return resource != null;
    }

    /**
     * @description Verifies ownership for an existing document. Used for update/delete.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && isExistingDoc();
    }

    /**
     * @description Verifies the author of a resource (e.g., a Post or Comment).
     * Used for update/delete rules on existing documents.
     */
    function isAuthorOf(docData) {
      return isSignedIn() && request.auth.uid == docData.authorId;
    }

    /**
     * @description Verifies the authorId on a new document matches the creator's UID.
     * Used for create rules.
     */
    function isSelfAssignedAuthor() {
      return isSignedIn() && request.auth.uid == request.resource.data.authorId;
    }
    
    /**
     * @description Verifies the userId on a new document matches the creator's UID.
     * Used for create rules on actions like Likes or Saves.
     */
    function isSelfAssignedUser() {
      return isSignedIn() && request.auth.uid == request.resource.data.userId;
    }

    /**
     * @description Ensures the authorId field is not changed during an update.
     */
    function authorIdIsImmutable() {
      return request.resource.data.authorId == resource.data.authorId;
    }
    
    /**
     * @description Ensures the userId field is not changed during an update.
     */
    function userIdIsImmutable() {
      return request.resource.data.userId == resource.data.userId;
    }

    // ----------------------------------------
    // User Profiles & Subcollections
    // ----------------------------------------

    /**
     * @description Rules for user profile documents.
     * @path /users/{userId}
     * @allow A user can create their own profile.
     * @allow Any user can read a profile.
     * @deny Listing all users.
     * @principle Enforces self-creation and ownership for writes, while allowing public reads for social features.
     */
    match /users/{userId} {
      allow get: if true;
      allow list: if false; // Privacy: prevent scraping all users.
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(userId);

      /**
       * @description A user's followers list. Anyone can read, only functions can write (for atomicity).
       * @path /users/{userId}/followers/{followerId}
       */
      match /followers/{followerId} {
        allow get, list: if true;
        allow create, update, delete: if false; // Managed by backend triggers
      }

      /**
       * @description A user's following list. Anyone can read, only functions can write (for atomicity).
       * @path /users/{userId}/following/{followingId}
       */
      match /following/{followingId} {
        allow get, list: if true;
        allow create, update, delete: if false; // Managed by backend triggers
      }
      
      /**
       * @description A user's saved/collected posts. Only the owner can view and modify.
       * @path /users/{userId}/saved_posts/{postId}
       */
      match /saved_posts/{postId} {
          allow get, list: if isOwner(userId);
          allow create: if isOwner(userId) && isSelfAssignedUser();
          allow delete: if isExistingOwner(userId) && resource.data.userId == request.auth.uid;
          allow update: if false;
      }

      /**
       * @description Rules for a user's private notification collection.
       * @path /users/{userId}/notifications/{notificationId}
       * @principle Enforces strict data privacy by confining access to the owner of the data tree.
       */
      match /notifications/{notificationId} {
        allow get, list: if isOwner(userId);
        allow create: if isOwner(userId) && request.resource.data.userId == userId; // Or from a trusted backend
        allow update: if isExistingOwner(userId) && request.resource.data.userId == resource.data.userId;
        allow delete: if isExistingOwner(userId);
      }
    }

    // ----------------------------------------
    // Global Content Collections
    // ----------------------------------------

    /**
     * @description Rules for the global posts collection.
     * @path /posts/{postId}
     * @principle Public Read with Owner-Only Writes. Allows content discovery while protecting author integrity.
     */
    match /posts/{postId} {
      allow get, list: if true;
      allow create: if isSelfAssignedAuthor();
      allow update: if isExistingDoc() && isAuthorOf(resource.data) && authorIdIsImmutable();
      allow delete: if isExistingDoc() && isAuthorOf(resource.data);

      /**
       * @description Rules for comments on a post.
       * @path /posts/{postId}/comments/{commentId}
       * @principle Public Read with Owner-Only Writes.
       */
      match /comments/{commentId} {
        allow get, list: if true;
        allow create: if isSelfAssignedAuthor() && request.resource.data.postId == postId;
        allow update: if isExistingDoc() && isAuthorOf(resource.data) && authorIdIsImmutable() && request.resource.data.postId == resource.data.postId;
        allow delete: if isExistingDoc() && isAuthorOf(resource.data);
      }
      
      /**
       * @description Rules for likes on a post.
       * @path /posts/{postId}/likes/{userId}
       * @principle Any signed-in user can like/unlike a post.
       */
      match /likes/{userId} {
        allow get, list: if true;
        allow create: if isOwner(userId) && isSelfAssignedUser();
        allow delete: if isOwner(userId) && isExistingDoc();
        allow update: if false;
      }
    }
  }
}
