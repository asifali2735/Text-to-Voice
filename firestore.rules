/**
 * Core Philosophy: This ruleset enforces a strict user-ownership model combined with role-based access for administrators.
 * Most user-specific data (profiles, posts, notifications) is nested under the `/users/{userId}` path,
 * allowing for clear, path-based authorization. Publicly readable data is explicitly opened up, while sensitive
 * operations are restricted to document owners or administrators. The default posture is to deny access.
 *
 * Data Structure: The data is organized into top-level collections for global entities (`users`, `followers`, `trending_topics`)
 * and user-specific subcollections (`posts`, `comments`, `notifications`, `recommendations`) nested under `/users/{userId}`.
 * This structure simplifies security by colocating data with its ownership context. Administrator roles are managed in a
 * dedicated `/roles_admin` collection, where the existence of a document signifies admin privileges for that user ID.
 *
 * Key Security Decisions:
 * - User Directory Protection: Listing the entire `/users` collection is explicitly disallowed to prevent scraping of user data.
 *   Implementing user search or "find friends" functionality should be done via a secure backend endpoint (e.g., a Cloud Function).
 * - System-Managed Collections: Collections like `trending_topics`, `recommendations`, and `notifications` are designated as
 *   system-managed. Regular users have read-only or limited update access, while all creation and deletion is restricted to admins.
 * - Ownership Enforcement: All user-generated content requires the user to be authenticated. Write operations (create, update, delete)
 *   are strictly limited to the user who owns the document. This is enforced by comparing `request.auth.uid` with an owner ID
 *   in the document path or data.
 * - Public vs. Private: User profiles and posts are readable by any signed-in user to facilitate social interaction. Private data
 *   like notifications and recommendations are readable only by the owner.
 *
 * Denormalization for Authorization: This ruleset relies on the data structure where user-specific data is nested under paths
 * containing the user's ID (e.g., `/users/{userId}/posts/{postId}`). This avoids costly `get()` calls to other documents for
 * basic ownership checks. Administrator roles are checked with a single, efficient `exists()` call to the `/roles_admin` collection.
 *
 * Structural Segregation: User-specific, private data like `notifications` and `recommendations` are stored in separate
 * subcollections under the user's document. This is more secure and performant than mixing public and private data in a single
 * collection with a visibility flag.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ----------------------------------------------------------------------
    // Helper Functions
    // ----------------------------------------------------------------------

    /**
     * Checks if a user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the currently authenticated user's ID matches the provided userId.
     * This is the primary function for enforcing document ownership.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }



    /**
     * Checks for ownership on an existing document. Used for update and delete
     * operations to prevent acting on non-existent data.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * Checks if the currently authenticated user is an administrator.
     * An admin is defined by the existence of a document for their UID
     * in the /roles_admin collection.
     */
    function isAdmin() {
      return isSignedIn() && exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
    }

    /**
     * Validates that the owner ID within a document cannot be changed after creation.
     */
    function isOwnerFieldImmutable(fieldName) {
      return request.resource.data[fieldName] == resource.data[fieldName];
    }

    // ----------------------------------------------------------------------
    // Admin Roles
    // ----------------------------------------------------------------------

    /**
     * @description Manages admin roles. Only other admins can view or modify this collection.
     * @path /roles_admin/{userId}
     * @allow (get) An admin can check if another user is an admin.
     * @deny (get) A non-admin user cannot read the admin list.
     * @principle Restricts sensitive role management to authorized administrators.
     */
    match /roles_admin/{userId} {
      allow get: if isAdmin();
      allow list: if isAdmin();
      allow create: if isAdmin();
      allow update: if isAdmin();
      allow delete: if isAdmin();
    }

    // ----------------------------------------------------------------------
    // User Profiles
    // ----------------------------------------------------------------------

    /**
     * @description Manages user profile documents.
     * @path /users/{userId}
     * @allow (create) A new user can create their own profile document.
     * @allow (get) Any signed-in user can view another user's profile.
     * @deny (list) Listing all users is forbidden to prevent data scraping.
     * @deny (update) A user cannot update another user's profile.
     * @principle A user has full control over their own profile, which is otherwise read-only to others.
     */
    match /users/{userId} {
      allow get: if isSignedIn();
      allow list: if false; // Deny listing all users to prevent scraping
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isExistingOwner(userId) && isOwnerFieldImmutable('id');
      allow delete: if isExistingOwner(userId);
    }

    // ----------------------------------------------------------------------
    // User-Owned Subcollections
    // ----------------------------------------------------------------------

    /**
     * @description Manages posts created by a user.
     * @path /users/{userId}/posts/{postId}
     * @allow (get) Any signed-in user can read a user's posts.
     * @allow (create) A user can create a post under their own profile.
     * @deny (update) A user cannot update a post belonging to someone else.
     * @principle Enforces document ownership for writes, while allowing public reads for social features.
     */
    match /users/{userId}/posts/{postId} {
      allow get: if isSignedIn();
      allow list: if isSignedIn();
      allow create: if isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isExistingOwner(userId) && isOwnerFieldImmutable('userId');
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Manages comments created by a user.
     * @path /users/{userId}/comments/{commentId}
     * @allow (get) Any signed-in user can read comments.
     * @allow (create) A user can create a comment under their own ID.
     * @deny (delete) A user cannot delete someone else's comment.
     * @principle Enforces document ownership for writes, while allowing public reads.
     */
    match /users/{userId}/comments/{commentId} {
      allow get: if isSignedIn();
      allow list: if isSignedIn();
      allow create: if isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isExistingOwner(userId) && isOwnerFieldImmutable('userId');
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Stores content recommendations for a user. These are read-only for the user.
     * @path /users/{userId}/recommendations/{recommendationId}
     * @allow (get, list) A user can read their own recommendations.
     * @deny (create) Only admins (the system) can create recommendations.
     * @deny (get) A user cannot read another user's recommendations.
     * @principle Segregates private, system-generated data to be readable only by its owner.
     */
    match /users/{userId}/recommendations/{recommendationId} {
      allow get: if isOwner(userId) || isAdmin();
      allow list: if isOwner(userId) || isAdmin();
      allow create: if isAdmin();
      allow update: if false; // Recommendations are immutable
      allow delete: if isAdmin();
    }

    /**
     * @description Stores notifications for a user. The user can read and update them (e.g., mark as read).
     * @path /users/{userId}/notifications/{notificationId}
     * @allow (update) A user can update a notification, e.g., to mark it as read.
     * @deny (create) Only admins (the system) can create notifications.
     * @deny (get) A user cannot read another user's notifications.
     * @principle Allows a user to modify state on their private, system-generated data.
     */
    match /users/{userId}/notifications/{notificationId} {
      allow get: if isOwner(userId) || isAdmin();
      allow list: if isOwner(userId) || isAdmin();
      allow create: if isAdmin();
      allow update: if isExistingOwner(userId);
      allow delete: if isAdmin();
    }

    // ----------------------------------------------------------------------
    // Global Collections
    // ----------------------------------------------------------------------

    /**
     * @description Manages follower relationships. The document ID is a composite key.
     * @path /followers/{followId}
     * @allow (create) A user can create a 'Follower' document to follow someone else.
     * @allow (delete) A user can delete their own 'Follower' document to unfollow.
     * @deny (create) A user cannot make another user follow someone.
     * @principle A user can only initiate or terminate their own 'follow' actions.
     */
    match /followers/{followId} {
      allow get: if isSignedIn();
      allow list: if isSignedIn();
      allow create: if isSignedIn() && request.resource.data.followerId == request.auth.uid;
      allow update: if false; // Follow relationships cannot be changed, only re-created.
      allow delete: if resource != null && resource.data.followerId == request.auth.uid;
    }

    /**
     * @description Manages trending topics. This data is public and read-only for users.
     * @path /trending_topics/{trendingTopicId}
     * @allow (get, list) Any client, authenticated or not, can read trending topics.
     * @deny (create) Only admins (the system) can create or modify trending topics.
     * @principle Provides public, read-only access to global application data.
     */
    match /trending_topics/{trendingTopicId} {
      allow get: if true;
      allow list: if true;
      allow create: if isAdmin();
      allow update: if isAdmin();
      allow delete: if isAdmin();
    }
  }
}